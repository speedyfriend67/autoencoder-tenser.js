<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Autoencoder Visualizer</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f4f4f4;
  }
  .container {
    text-align: center;
  }
  input, button {
    margin: 5px;
    padding: 8px;
  }
  canvas {
    border: 1px solid #ccc;
    background-color: #fff;
    margin-top: 10px;
  }
  .progress {
    margin-top: 10px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Autoencoder Visualizer</h1>
  <input type="text" id="inputData" placeholder="Enter input data (comma-separated)">
  <br>
  <label for="encodingUnits">Encoding Units:</label>
  <input type="number" id="encodingUnits" min="1" value="2">
  <br>
  <label for="learningRate">Learning Rate:</label>
  <input type="range" id="learningRate" min="0.001" max="0.1" step="0.001" value="0.01">
  <br>
  <label for="epochs">Epochs:</label>
  <input type="range" id="epochs" min="10" max="200" step="10" value="100">
  <br>
  <button onclick="visualize()">Visualize</button>
  <button onclick="resetCanvas()">Reset Canvas</button>
  <button onclick="clearInput()">Clear Input</button>
  <button onclick="toggleColor()">Toggle Color</button>
  <br>
  <canvas id="canvas" width="200" height="200"></canvas>
  <br>
  <canvas id="decodedCanvas" width="200" height="200"></canvas>
  <p id="error"></p>
  <div class="progress" id="progress"></div>
</div>

<!-- Load TensorFlow.js library -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0"></script>
<script>
let colorToggle = false;

async function visualize() {
  const inputData = document.getElementById('inputData').value.split(',').map(Number);
  const encodingUnits = parseInt(document.getElementById('encodingUnits').value, 10);
  const learningRate = parseFloat(document.getElementById('learningRate').value);
  const epochs = parseInt(document.getElementById('epochs').value, 10);

  // Define the model architecture
  const model = tf.sequential();
  model.add(tf.layers.dense({ inputShape: [inputData.length], units: encodingUnits, activation: 'relu' }));
  model.add(tf.layers.dense({ units: inputData.length, activation: 'sigmoid' }));

  // Compile the model
  model.compile({ optimizer: tf.train.adam(learningRate), loss: 'meanSquaredError' });

  // Train the model with random data (no real training data provided)
  const trainingData = tf.randomNormal([10, inputData.length]);

  // Display training progress
  const progressBar = document.getElementById('progress');
  progressBar.innerHTML = 'Training in progress...';

  await model.fit(trainingData, trainingData, {
    epochs,
    verbose: 0,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        progressBar.innerHTML = `Epoch ${epoch + 1}/${epochs} - Loss: ${logs.loss.toFixed(4)}`;
      },
    },
  });

  progressBar.innerHTML = '';

  // Encode and decode input data
  const encodedData = model.predict(tf.tensor2d([inputData]));
  const decodedData = model.predict(encodedData);

  // Calculate reconstruction error
  const error = tf.metrics.meanSquaredError(tf.tensor2d([inputData]), decodedData).dataSync()[0];

  // Visualize encoded data
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'blue';
  ctx.fillRect(10, 10, encodedData.dataSync()[0] * 100, encodedData.dataSync()[1] * 100);
  
  // Visualize decoded data
  const decodedCanvas = document.getElementById('decodedCanvas');
  const decodedCtx = decodedCanvas.getContext('2d');
  decodedCtx.clearRect(0, 0, decodedCanvas.width, decodedCanvas.height);

  const decodedPixels = decodedData.dataSync();
  const imageData = decodedCtx.createImageData(decodedCanvas.width, decodedCanvas.height);

  // Toggle between grayscale and color
  if (colorToggle) {
    for (let i = 0; i < decodedPixels.length; i++) {
      const value = Math.round(decodedPixels[i] * 255);
      imageData.data[i * 4] = value; // Red
      imageData.data[i * 4 + 1] = value; // Green
      imageData.data[i * 4 + 2] = value; // Blue
      imageData.data[i * 4 + 3] = 255; // Alpha
    }
  } else {
    for (let i = 0; i < decodedPixels.length; i++) {
      const value = Math.round(decodedPixels[i] * 255);
      imageData.data[i * 4] = value; // Red
      imageData.data[i * 4 + 1] = value; // Green
      imageData.data[i * 4 + 2] = value; // Blue
      imageData.data[i * 4 + 3] = 255; // Alpha
    }
  }

  decodedCtx.putImageData(imageData, 0, 0);

  // Display reconstruction error
  document.getElementById('error').innerText = `Reconstruction Error: ${error.toFixed(4)}`;
}

function resetCanvas() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const decodedCanvas = document.getElementById('decodedCanvas');
  const decodedCtx = decodedCanvas.getContext('2d');
  decodedCtx.clearRect(0, 0, decodedCanvas.width, decodedCanvas.height);

  document.getElementById('error').innerText = '';
}

function clearInput() {
  document.getElementById('inputData').value = '';
}

function toggleColor() {
  colorToggle = !colorToggle;
  visualize();
}
</script>
</body>
</html>

